# 数组实现二叉树

链表可以通过指针访问元素, 那么数组如何访问呢, 自然是 `索引` .

## 数组表示完美二叉树

给定一个完美二叉树, 那么每个节点的索引都可以确定, 如下图所示:

![完美二叉树索引](https://raw.githubusercontent.com/harisonkhlil/oss/main/uPic/NQ8Lut.png)

根据层序遍历的特性, 我们可以推导出节点以及其子节点的 **索引** 的 `映射公式` : 若节点的索引是 `i`, 则该节点的左子节点索引为 `2i+1` , 则该节点的右子节点索引为 `2i+2`

那么映射公式的作用是什么呢? 映射公式的作用相当于链表的指针. 如果将所有的节点按照层序遍历存储在一个数组中, 那么对于数组中的任意节点, 我们都可以通过映射公式找到其子节点

## 数组表示任意二叉树

普通的二叉树具有许多的 $None$, 而层序遍历并不包含这些 $None$ . 意味着**存在多种二叉树结构都符合层序遍历序列**已经失效. 为了解决这个问题, **可以直接考虑在层序遍历序列中显式的写出所有的 $None$ . 如下图所示:

![补全的任意二叉树](https://raw.githubusercontent.com/harisonkhlil/oss/main/uPic/QtSmWl.png)

```cpp
// 使用 int 最大值标记空位, 因此要求节点值不能为 INT_MAX
vector<int> tree {1, 2, 3, 4, INT_MAX, 6, 7, 8, 9, INT_MAX, INT_MAX, 12 ...};
```

## 数组表示的优势与局限

优点:

- 数组存储在连续的内存空间中, 缓存友好, 访问与遍历速度较快
- 不需要存储指针, 节省空间
- 允许随机访问节点

局限:

- 数组需要连续的内存空间, 因此不适合存储数据量过大的树
- 增删节点需要通过数组插入和删除操作, 效率比较低
- 当二叉树存在大量的 $None$ 节点时, 数组中的有效节点数据比重较低, 空间利用率低.

但是用数组表示 **完全二叉树** 则非常完美, 使用此表示方法可以省略存储所有的 $None$

![array to binary_tree](https://raw.githubusercontent.com/harisonkhlil/oss/main/uPic/qzXVb7.png)
