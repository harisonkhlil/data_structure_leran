# 空间复杂度

## 定义

「空间复杂度 Space Complexity」用于衡量算法使用内存空间随着数据量变大时的增长趋势。这个概念与时间复杂度非常类似。

算法的空问复杂度通过计算算法所需的存储空间实现，算法的空间复杂度计算公式：
$$
S(n) = O(f(n)) \tag{1.0}
$$
其中，n 为问题的规模，$f(n)$ 为语句关于 n 所占存储空间的函数

## 算法相关空间

* 输入空间：用于存储算法的输入数据
* 暂存空间：用于存储算法运行过程中的变量、对象、函数上下文等
* 输出空间：用于存储算法的输出数据

**通常情况下，空间复杂度统计范围是*暂存空间* + *输出空间***

同时：
$$
暂存空间 = \begin{cases}
暂存数据：用于保存算法运行过程中的各种常量、变量、对象 \newline
栈帧空间： 用于保存调用函数的上下文数据，函数返回后，栈帧空间会被释放 \newline
指令空间：用于保存编译后的程序指令，但是通常忽略不计
\end{cases} \tag{2.0}
$$

## 推算方法

**我们通常只关注「最差空间复杂度」**，这是因为内存空间是一项硬性要求，我们必须确保在所有输入数据下都有足够的内存空间预留。

**最差空间复杂度中的“最差”有两层含义**，分别是输入数据的最差分布和算法运行过程中的最差时间点。

1. **以最差输入数据为准**。
2. **以算法运行过程中的峰值内存为准**。

实例：

```cpp
int Func() {
//  do something
  return 0;
}
void loop(int n) {
  for (int i = 0; i < n; ++i) {
    func();
  }
}
/* recursion O(n) */
void Recursion(int n) {
  if (n == 1) return;
  return Recursion(n-1);
}
```

再循环中循环了 n 次但是每次都被释放了`栈帧空间`，所以时间复杂度是 $O(1)$在递归函数中，由于执行了 n 次，没有释放`栈帧空间`，故空间复杂度是 $O(n)$

## 常见类型

设置输入数据大小为 n，常见的空间复杂度有：
$$
\begin{aligned}
O(1) < O(\log n) < O(n) < O(n^2) < O(2^n) \newline
\text{常数阶} < \text{对数阶} < \text{线性阶} < \text{平方阶} < \text{指数阶}
\end{aligned} \tag{3.0}
$$


![空间复杂度的常见类型](https://www.hello-algo.com/chapter_computational_complexity/space_complexity.assets/space_complexity_common_types.png)

<center> 空间复杂度常用类型 </center>

**图片“空间复杂度的常见类型”反映的是否是占用空间的绝对大小？**

> 不是，该图片展示的是空间复杂度（即增长趋势），而不是占用空间的绝对大小。每个曲线都包含一个常数项，用来把所有曲线的取值范围压缩到一个视觉舒适的范围内。 实际中，因为我们通常不知道每个方法的“常数项”复杂度是多少，所以一般无法仅凭复杂度来选择 $n = 8$ 之下的最优解法；但相对地 $n = 8^5$ 就很好选了，这是复杂度占主导的情况。

## 权衡时间和空间

**降低时间复杂度通常需要以提升空间复杂度为代价，反之亦然**。我们将牺牲内存空间来提升算法运行速度的思路称为“以空间换时间”；反之，则称为“以时间换空间”。

选择哪种思路取决于我们更看重哪个方面。在大多数情况下，时间比空间更宝贵，因此以空间换时间通常是更常用的策略。当然，在数据量很大的情况下，控制空间复杂度也是非常重要的。

**函数和方法这两个术语的区别是什么？**

> 函数（function）可以独立被执行，所有参数都以显式传递。 方法（method）与一个对象关联，方法被隐式传递给调用它的对象，方法能够对类的实例中包含的数据进行操作。
>
> 因此，C 和 Go 只有函数，Java 和 C# 只有方法，在 C++, Python 中取决于它是否属于一个类。