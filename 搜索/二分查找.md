# 二分查找

「二分查找 Binary Search」是一种基于分治思想的高效搜索算法。它利用数据的有序性，每轮减少一半搜索范围，直至找到目标元素或搜索区间为空为止。

> 给定一个长度为 n  的数组 nums ，元素按从小到大的顺序排列，数组不包含重复元素。请查找并返回元素 target 在该数组中的索引。若数组不包含该元素，则返回 -1

解决思路:

1. 初始化两个指针, 一个指向数组的头 `i = 0`, 另一个指向数组的尾 `j = n -1`
2. 找到这个数组的中值索引 $m = (i + j) / 2$
   1. 如果 `nums[m] < target` 则令 `i = m + 1`;
   2. 如果 `nums[m] > target` 则令 `j = m - 1`;
   3. 如果 `nums[m] == traget` 则返回 m;
3. 循环 2, 如果没有找到则返回 -1

## 算法实现

**tips**: 由于 $i$ 与 $j$ 都是 `int` 类型, $i + j$ 可能会超出 int 类型的取值范围, 所以通常使用 $m = [i + (j -i) / 2]$ 来计算中点

```cpp
/* 二分查找（双闭区间） */
int binarySearch(vector<int> &nums, int target) {
    // 初始化双闭区间 [0, n-1] ，即 i, j 分别指向数组首元素、尾元素
    int i = 0, j = nums.size() - 1;
    // 循环，当搜索区间为空时跳出（当 i > j 时为空）
    while (i <= j) {
        int m = i + (j - i) / 2; // 计算中点索引 m
        if (nums[m] < target)    // 此情况说明 target 在区间 [m+1, j] 中
            i = m + 1;
        else if (nums[m] > target) // 此情况说明 target 在区间 [i, m-1] 中
            j = m - 1;
        else // 找到目标元素，返回其索引
            return m;
    }
    // 未找到目标元素，返回 -1
    return -1;
}
```

`时间复杂度`: 每轮缩小一半的区间, 因此二分循环的时间复杂度是 $O(\log_{2}{n})$ 所以二分查找的时间复杂度是 $O(\log{n})$;

`空间复杂度`: 由于 $i$ 和 $j$ 使用的都是常量空间, 故空间复杂度是 $O(1)$;

## 区间表示方法

除了上述的双闭区间外，常见的区间表示还有“左闭右开”区间, 定义为 $[0, n)$ 即左边界包含自身，右边界不包含自身。在该表示下，区间在 $i = j$ 时为空. 具体区别如下图所示:

![](https://www.hello-algo.com/chapter_searching/binary_search.assets/binary_search_ranges.png)

## 优点以及局限

二分查找在时间和空间方面都有较好的性能：

- 二分查找的时间效率高。在大数据量下，对数阶的时间复杂度具有显著优势。例如，当数据大小 $n = 2^20$ 线性查找需要 $2^{20} = 1048576$ 而二分查找仅需 $\log_2 2^{20} = 20$, 仅仅 20 轮循环即可找到
- 二分查找无需额外空间。相较于需要借助额外空间的搜索算法（例如哈希查找），二分查找更加节省空间。

局限:

- 二分查找仅适用于有序数据。若输入数据无序，为了使用二分查找而专门进行排序，得不偿失。因为排序算法的时间复杂度通常为 $O(n\log{n})$ 比线性查找和二分查找都更高。对于频繁插入元素的场景，为保持数组有序性，需要将元素插入到特定位置，时间复杂度为 $O(n)$ 也是非常昂贵的。
- 二分查找仅适用于数组。二分查找需要跳跃式（非连续地）访问元素，而在链表中执行跳跃式访问的效率较低，因此不适合应用在链表或基于链表实现的数据结构。
- 小数据量下，线性查找性能更佳。在线性查找中，每轮只需要 1 次判断操作；而在二分查找中，需要 1 次加法、1 次除法、1 ~ 3 次判断操作、1 次加法（减法），共 4 ~ 6 个单元操作；因此，当数据量 n 较小时，线性查找反而比二分查找更快。

## 二分查找边界

题目规定数组中所有元素都是唯一的。如果目标元素在数组中多次出现，上节介绍的方法只能保证返回其中一个目标元素的索引，**而无法确定该索引的左边和右边还有多少目标元素**。

### 线性方法

为了查找数组中最左边的 target ，我们可以分为两步：

1. 进行二分查找，定位到任意一个 target 的索引，记为 `k`
2. 以索引 `k` 为起始点，向左进行线性遍历，找到最左边的 target 返回即可

这个方法虽然有效，但由于包含线性查找，时间复杂度为 $O(n)$ 当存在很多重复的 target 时效率较低。

### 二分查找左区间

考虑仅使用二分查找解决该问题。整体算法流程不变，先计算中点索引 `m` 再判断 target 和 nums[m] 大小关系：

- 当 nums[m] < target 或 nums[m] > target 时，说明还没有找到 target ，因此采取与上节代码相同的缩小区间操作，从而使指针 `i` 和 `j` 向 target 靠近
- 当 nums[m] == target 时，说明“小于 target 的元素”在区间 $[i, m-1)$ 中, 因此采用 $j = m-1$ 来缩小区间，从而使指针 `j`向小于 target 的元素靠近。

二分查找完成后，**$i$ 指向最左边的 `target` ，$j$ 指向首个小于 `target` 的元素**，因此返回索引 $i$ 即可。

```cpp
/* 二分查找最左一个元素 */
int binarySearchLeftEdge(vector<int> &nums, int target) {
    int i = 0, j = nums.size() - 1; // 初始化双闭区间 [0, n-1]
    while (i <= j) {
        int m = i + (j - i) / 2; // 计算中点索引 m
        if (nums[m] < target)
            i = m + 1; // target 在区间 [m+1, j] 中
        else if (nums[m] > target)
            j = m - 1; // target 在区间 [i, m-1] 中
        else
            j = m - 1; // 首个小于 target 的元素在区间 [i, m-1] 中
    }
    if (i == nums.size() || nums[i] != target)
        return -1; // 未找到目标元素，返回 -1
    return i;
}
```

### 二分查找右区间

类似地，我们也可以二分查找最右边的 `target` 。当 `nums[m] == target` 时，说明大于 `target` 的元素在区间 $[m + 1, j]$ 中，因此执行 `i = m + 1` ，**使得指针 $i$ 向大于 `target` 的元素靠近**。

完成二分后，**$i$ 指向首个大于 `target` 的元素，$j$ 指向最右边的 `target`** ，因此返回索引 $j$ 即可。

```cpp
/* 二分查找最右一个元素 */
int binarySearchRightEdge(vector<int> &nums, int target) {
    int i = 0, j = nums.size() - 1; // 初始化双闭区间 [0, n-1]
    while (i <= j) {
        int m = i + (j - i) / 2; // 计算中点索引 m
        if (nums[m] < target)
            i = m + 1; // target 在区间 [m+1, j] 中
        else if (nums[m] > target)
            j = m - 1; // target 在区间 [i, m-1] 中
        else
            i = m + 1; // 首个大于 target 的元素在区间 [m+1, j] 中
    }
    if (j < 0 || nums[j] != target)
        return -1; // 未找到目标元素，返回 -1
    return j;
}
```